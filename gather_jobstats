#!/usr/bin/env perl

# DONE: (lka) help information about flag:number:number values
# DONE: (lka) verbose flag to be wordy about flag output?
# DONE: (lka) get current cluster from $SNIC_RESOURCE
# DONE: (lka) memory flag, perhaps only include if already a cores issue?
# TODO: (lka) problem with plots from 100-node tintin job, and with 10-node tintin job
# TODO: add usage of Martin's sqlite3 db if it is available (i.e. if we are on milou-b)
# TODO: is there another, deeper, location for jobstats files we can check?
# TODO: perhaps include more about user, jobstate in plot and table?

my $version = "2015-02-09";

use strict;
use warnings;
# use diagnostics;

use Getopt::Long qw(:config no_ignore_case);
use File::Basename;
use Cwd 'abs_path';

my $CWD = dirname(abs_path($0));
my $NAME = basename($0);

my $cluster = $ENV{'SNIC_RESOURCE'};  # -M
my $do_plot = 0;         # -P
my $memory = 0;          # -m
my $nodes;               # -n
my @nodes;               # after unpacking finishedjobinfo or -n
my @jobs;                # user-specified jobids
my $help;                # -h
my $stdin = 0;           # -- which indicates accepting finishedjobinfo info on stdin
my $print_header = 0;    # -d
my $verbose = 0;         # -v
my $quiet = 0;           # -q
my $finishedjobinfo = "/sw/uppmax/bin/finishedjobinfo"; # -f
my $plot_jobstats_R = "$CWD/plot_jobstats.R"; # -s
my $prefix = "/sw/share/slurm"; # -x
my $hard_prefix = "";    # -X
my $usage = "
$NAME  [-h] [-p] [options] [ -M cluster ] [ -n node[,node...] ] [ jobid [ jobid ... ] | - ]

Discover jobstats for the specified job(s) on the specified cluster.

With the -p option, produce a plot for each jobid.  Plots contain one panel per
booked node showing CPU and memory usage, and include lines indicating the
usage flags.  Plots are saved to the current directory with the name
'cluster-jobid.png'.

Cluster defaults to the value of \$SNIC_RESOURCE ('$ENV{SNIC_RESOURCE}' on the current system)
if not specified.  There are three distinct modes for discovery about jobs of
interest.

  1. finishedjobinfo is used to discover information about jobs

         $NAME jobid1 jobid2 jobid3

  2. If the -n option is specified, then finishedjobinfo is not called and 
     jobstats files are sought directly for only the specified nodes

         $NAME -p -n m15,m16 jobid1
    
  3. Standard input is output from finishedjobinfo, which is then parsed for
     discovery.  Jobids examined are those present in the input.  This mode
     is enabled by using the - option and providing appropriate input on stdin,
     e.g.,

       finishedjobinfo project | grep 'jobstat=COMPLETED' | $NAME - -q -p
  
Note that not all jobs will produce jobstats files, particularly if the job was
cancelled or ran for less than 5 minutes.  Also, if a job booked nodes
inefficiently by not using nodes it asked for, jobstats files will not be
available for the booked but unused nodes.

Output for each job is a tab-separated line with the following fields:

  jobid cluster endtime runtime flags booked cores node[,node...] jobstats[,jobstats...] 

Field contents:

  jobid    : Job ID
  cluster  : Cluster on which the job was run
  endtime  : End time of the job (with -n, this is '.')
  runtime  : Runtime of the job (with -n, this is '.')
  flags    : Flags indicating various types of resource underutilizations.
  booked   : Number of booked cores (with -n, this is '.')
  cores    : Number of cores represented in the discovered jobstats files.
  node     : Node(s) booked for the job, expanded into individual node names,
             separated by commas ','; if no nodes were found, this is '.'.  
             The nodes for which jobstats files are available are listed first.

  jobstats : jobstats files for the nodes, in the same order the nodes are 
             listed, separated by commas ','; if no jobstats files, this is '.'

The 'flags' field is a comma-separated list of cautions regarding core and/or
memory underutilisation.  Some flags have a threshold below which they appear.
The default format is:

  flag:value-booked:value-used

Flags:

  cores_underused
      More cores were booked than used.
  mem_underused
      More memory was available than was used (if < 25%).
  core_mem_underused
      Less memory was used than was available in the cores that were used (if < 50%).
  node_half_underused
      No more than 1/2 of both cores and memory of a node was used; consider booking 
      half a node instead.
  node_severely_underused
      No more than 1/4 of both cores and memory of a node was used, examine your job
      requirements closely.
  node_type_misbooked
      A fat node was requested that was larger than was needed.  This flag may be
      produced spuriously of SLURM ran the job on a fat node when a fat node was not
      requested.

By default no flags are indicated for jobs with memory-only cautions; use the
-m option to include these flags on such jobs.  More verbose flags are output
with the -v option.

Options:

    -M cluster         Cluster on which the job was run [default here is '$cluster']
    -n node[,node...]  Cluster node(s) on which the job was run.  If specified, then
                       the finishedjobinfo script is not run and discovery is
                       restricted to only the specified nodes.  Nodes can be specified
                       as a comma-separated list of complete node names, or using the
                       finishedjobinfo syntax:
                             m78,m90,m91,m92,m100  or  m[78,90-92,100]
                       Nonsensical results will occur if the syntaxes are mixed.
    - | --stdin        Accept input on stdin formatted like finishedjobinfo output.
                       The short form of this option is a single dash '-'.

    -m | --memory      Always include memory usage flags in output.  Default behaviour
                       is to include memory usage flags only if CPU usage flags are also
                       present.

    -v | --verbose     Be wordy when describing flag values.

    -p | --plot        Produce CPU and memory usage plot for each jobid

    -d                 Produce a header for table output
    -q                 Do not produce table output.  If -p is not specified, then the
                       script produces no output but still continues with discovery.

    -x directory       Directory prefix to use for jobstats files.  Default is
                       '$prefix', and directory structure is 

                           <prefix>/<cluster>/uppmax_jobstats/<node>/<jobid>

    -X directory       Hard directory prefix to use for jobstats files.  Jobstats files
                       are assumed available directly: '<hard-prefix>/<jobid>'
    -f file            finishedjobinfo script [default is '$finishedjobinfo']
    -s file            plot_jobstats.R script [default is '$plot_jobstats_R']
    -h                 This help information

    jobid [jobid ...]  Job number valid on the specified cluster

Location: $0
Version:  $version
";

GetOptions("M=s"     => \$cluster, 
           "n=s"     => \$nodes,
           ""        => \$stdin,
           "stdin"   => \$stdin,
           "memory"  => \$memory,
           "verbose" => \$verbose,
           "plot"    => \$do_plot,
           "d"       => \$print_header,
           "q"       => \$quiet,
           "x=s"     => \$prefix,
           "X=s"     => \$hard_prefix,
           "f=s"     => \$finishedjobinfo,
           "s=s"     => \$plot_jobstats_R,
           "help"    => \$help) or die "$usage";
die "$usage" if $help;

@jobs = @ARGV;

($cluster and ($stdin or scalar(@jobs) >= 1)) or die "\n*** At least one jobid is required.\n$usage";

my $PREFIX = ( $hard_prefix ? $hard_prefix : "$prefix/$cluster/uppmax_jobstats" );

-d "$PREFIX" or die "\n*** Jobstats directory prefix '$PREFIX/' is not a directory.\n$usage";

my $username = scalar getpwuid $<;
my @user_groups = map { scalar getgrgid $_ } split ' ', $(;
my $in_staff = (scalar(grep /^staff$/, @user_groups) or ($username eq "root"));

sub parseFinishedjobinfoLine($);
sub jobInfo($);
sub parseNodes($);
sub getJobstatsFiles($$@);
sub getJobstatsFileCoreCount($);
sub reorderNodeList($$);
sub runPlotJobstats(@);

# parse a single finishedjobinfo-formatted line and return a hash
sub parseFinishedjobinfoLine($) {
    my $line = shift;
    chomp $line;
    my (undef, undef, $keyvals) = split (/ /, $line, 3);
    return(0) if (! defined($keyvals));
    # note that null values "... nodes= ..." will result in no key in the hash
    my %h = $keyvals =~ /([^ ]+)=([^ ]+)/g;
    return(\%h);
}

# discover jobinfo for a single job using finishedjobinfo script
sub jobInfo($) {
    my $j = shift;
    -f "$finishedjobinfo" or die "\n*** finishedjobinfo script '$finishedjobinfo' not available";
    return parseFinishedjobinfoLine(qx($finishedjobinfo -q -M $cluster -j $j));
}

# parse list of nodes returned by finishedjobinfo or provided on -n
sub parseNodes($) {
    my $nodes = shift;
    # nodes=                                # nodes=m80
    # nodes=m[26,74-75,77-78,81-84,88-89]   # nodes=m[100-101,103-104]
    # nodes=m[57,135-137]                   # nodes=m[135-136]
    # nodes=m2,m3,m4,m5
    # nonsensical results if finishedjobinfo-style and comma-separated are mixed
    if ($nodes !~ /\[/) { # 0 or 1 nodes or comma-separated
        return ( $nodes =~ /,/ ? split(/,/, $nodes) : $nodes ); 
    }
    $nodes =~ s/^(.+)\[(.*)\]$/$2/g;  # strip off 'prefix'[ and ]
    my $node_prefix = $1;
    my @node_nums;
    foreach my $p ( split /,/, $nodes ) {
        my @r = split /-/, $p;
        push @node_nums, ($#r ? ($r[0] .. $r[1]) : $r[0]);
    }
    return map { $node_prefix . $_ } @node_nums;
}

# find jobstats files, if they exist
sub getJobstatsFiles($$@) {  # cluster jobid node-list
    my $cluster = shift; 
    my $jobid = shift; 
    my @node_list = @_;
    # print STDERR "cluster:$cluster jobid:$jobid nodelist:", join(",", @node_list), "\n";
    my @file_list;
    foreach my $node ( @node_list ) {
        my $fn = ( $hard_prefix ? "$PREFIX/$jobid" : "$PREFIX/$node/$jobid" );
        -f $fn and -s $fn and push @file_list, $fn;
    }
    return @file_list;
}

# look in jobstats file for number of cores used
sub getJobstatsFileCoreCount($) {
    my $file = shift;
    open(F, "<$file") or die "*** Could not open jobstats file $file: $!";
    scalar(<F>); # header line
    my $l = <F>; # first data line
    # first 5 fields are LOCALTIME, TIME, GB_LIMIT, GB_USED, GB_SWAP_USED
    my @f = split /[ \t]+/, $l;
    return scalar(@f) - 5;
}

# reorder node list putting nodes with jobstats files first
sub reorderNodeList($$) {
    my $nl = shift; my $fl = shift;
    my @old_node_list = @{$nl};
    my @file_list = @{$fl};
    my @new_node_list;
    my %seen;
    foreach my $file ( @file_list ) {
        my @p = split("/", $file);
        push @new_node_list, $p[-2];  # node name
        ++$seen{$p[-2]};
    }
    push @new_node_list, grep { $seen{$_} ? () : $_ } @old_node_list;
    return(@new_node_list);
}

sub runPlotJobstats(@) {
    my @args = @_;
    -f "$plot_jobstats_R" or die "\n*** plot_jobstats.R script '$plot_jobstats_R' not available";
    unshift @args, "--full";   # must be just before @_
    unshift @args, "--memory" if $memory;  # must be before --full
    unshift @args, "--verbose" if $verbose;  # must be before --memory
    unshift @args, "--no-plot" if ! $do_plot;  # must be first arg
    my $flags = qx($plot_jobstats_R @args);
    chomp $flags;
    return($flags);
}

sub print_JobNotRun($) {
    my $ji = shift;
    my @fields = ($ji->{jobid}, $cluster, ".", $ji->{runtime}, "not_run", $ji->{procs}, ".", ".", ".");;
    print_JobRun(@fields);
}

my $header = "jobid\tcluster\tendtime\truntime\tflag_list\tbooked\tcore_list\tnode_list\tjobstats_list";

sub print_JobRun(@) {
    my @fields = @_;
    if ($print_header) {  # don't print the header until ready to create output
        print STDOUT $header, "\n" if ! $quiet;
        $print_header = 0;
    }
    print STDOUT join("\t", @fields), "\n" if ! $quiet;
}

@nodes = parseNodes($nodes) if $nodes;

while ( 1 ) {

    my $jobid;
    my $input_line;

    if ($stdin) {
        $input_line = <>;
        last if ! $input_line;
    } else {
        last if ! @jobs;
        $jobid = shift @jobs;
    }

    # $cluster already declared above
    my $endtime = '.';
    my $runtime = '.';
    my $booked = '.';
    my $total_cores = 0;
    my @flag_list;
    my @core_list;
    my @node_list;
    my @file_list,
    my @jobstats_list;

    if (@nodes) {  # -n was used, use this list
        @node_list = @nodes;
    } else {  # discover using finishedjobinfo or stdin
        my $ji;
        if ($stdin) {
            $ji = parseFinishedjobinfoLine($input_line);
            die "*** Jobid cannot be found, inconsistency in stdin input" if ! $ji;
            $jobid = $ji->{jobid};
        } else {
            $ji = jobInfo($jobid);
            if (! $ji) {  # couldn't find jobinfo, give error and skip to next
                print STDERR "*** Jobid $jobid cannot be found\n";
                next;
            }
            if (! scalar(grep /^$ji->{account}$/, @user_groups) and ! $in_staff) {
                print STDERR "*** Please, do not check other projects (jobid $jobid in $ji->{account})\n";
                next;
            }
        }
        if (! defined($ji->{nodes})) {  # appears the job never started
            print_JobNotRun($ji);
            next;
        }
        @node_list = parseNodes($ji->{nodes});
        $endtime = $ji->{end_time};
        $runtime = $ji->{runtime};
        $booked = $ji->{procs};
    }
    @file_list = getJobstatsFiles($cluster, $jobid, @node_list);
    @node_list = reorderNodeList(\@node_list, \@file_list);
    foreach ( @file_list ) {
        my $cores = getJobstatsFileCoreCount($_);
        $total_cores += $cores;
        push @core_list, $cores;
    }

    # check flags that we can easily check here, overridden if there are R script results
    if (@file_list and @file_list < @node_list) {
        if ($verbose) {
            push @flag_list, scalar(@node_list) . " nodes booked but " . scalar(@file_list) . " used";
        } else {
            push @flag_list, "nodes_overbooked:" . scalar(@node_list) . ":" . scalar(@file_list);
        }
    }
    if (@file_list and $booked ne '.' and $total_cores < $booked) {
        if ($verbose) {
            push @flag_list, scalar(@node_list) . " cores booked but " . scalar(@file_list) . " used";
        } else {
            push @flag_list, "cores_overbooked:" . $booked . ":" . $total_cores;
        }
    }
    # jobid cluster endtime runtime flag-list booked cores node-list jobstats-file-list
    my @fields;
    push @fields, $jobid;  # 0
    push @fields, $cluster; # 1
    push @fields, $endtime; # 2
    push @fields, $runtime; # 3
    push @fields, (@flag_list ? join(",", @flag_list) : "."); # 4
    push @fields, $booked; # 5
    push @fields, (@core_list ? join(",", @core_list) : "."); # 6
    push @fields, join(",", @node_list); # 7
    push @fields, (@file_list ? join(",", @file_list) : "."); # 8

    # if we have files to read, run plot_jobstats.R script to check more flags and produce a plot
    if (@file_list) {
        my $pjs_flags = runPlotJobstats(@fields);
        $fields[4] = $pjs_flags if $pjs_flags;
    }

    print_JobRun(@fields);

}

