#!/usr/bin/perl

# TODO: carry through node identity without having to parse jobstats filename,
#       perhaps by having the node list be in order of used nodes, then unused
#       nodes... DONE using reorderNodeList()

use strict;
use warnings;

use Getopt::Long;

my $version = "2014-03-24";

my $cluster = "milou";   # -M
my $nodes;               # -n
my @nodes;               # after unpacking finishedjobinfo or -n
my @jobs;                # user-specified jobids
my $help;                # -h
my $suppress_header = 0; # -d
my $finishedjobinfo = "/sw/uppmax/bin/finishedjobinfo"; # -f
my $prefix = "/sw/share/slurm";                         # -p
my $usage = "
$0  [-h] [ -p dir ] [ -f file] -M cluster [ -n node[,node...] ] jobid [ jobid ... ]

Discover jobstats for the specified job(s) on the specified cluster.  

Cluster is assumed '$cluster' if not specified.  The finishedjobinfo script is
used to discover information about the job unless the -n option is specified.
The -n option bypasses the script and will only return jobstats files for the
specified node(s).

Note that not all jobs will produce jobstats files.  Also, if a job booked
nodes inefficiently by not using node(s) it asked for, jobstats files will
not be available for the booked but unused nodes.

Output for each job is a tab-separated line with the following fields:

  jobid cluster endtime booked cores node[,node...] /path/to/jobstats[,/path/to/jobstats...] 

Field contents:

  jobid    : the job ID
  cluster  : cluster on which the job was run
  endtime  : end time of the job (with -n, this is '.')
  booked   : the number of booked cores (with -n, this is '.')
  cores    : the number of cores represented in the discovered jobstats files.
  node     : the node(s) booked for the job, expanded into individual node names,
             separated by commas ','; if no nodes were found, this is '.'
  jobstats : the jobstats files for the nodes, in the same order the nodes are listed,
             separated by commas ','; if no jobstats files were found, this is '.'

Options:

    -M cluster         Cluster on which the job was run [default is '$cluster']
    -n node[,node...]  Cluster node(s) on which the job was run.  If specified, then
                       the finishedjobinfo script is not run and discovery is
                       restricted to only the specified nodes
    -h                 This help information
    -d                 Do not produce a header for the output
    -p directory       Directory prefix to use for jobstats files [default is '$prefix']
                       Directory structure is '<prefix>/<cluster>/uppmax_jobstats/<node>/i<jobid>'
    -f file            finishedjobinfo script [default is '$finishedjobinfo']

    jobid [jobid ...]  Job number valid on the specified cluster

";

GetOptions("M=s" => \$cluster, 
           "n=s" => \$nodes,
           "d"   => \$suppress_header,
           "p=s" => \$prefix,
           "f=s" => \$finishedjobinfo,
	   "h"   => \$help) or die "$usage";
die "$usage" if $help;

@jobs = @ARGV;

($cluster and scalar(@jobs) >= 1) or die "\n*** At least one jobid is required.\n$usage";

-d "$prefix/$cluster/uppmax_jobstats/" or die "\n*** Prefix subdirectory '$prefix/$cluster/uppmax_jobstats/' is not a directory.\n$usage";

@nodes = split /,/, $nodes if $nodes;

# discover jobinfo using finishedjobinfo script
sub jobInfo($) {
	# TODO: handle unknown jobid here, what does fji return?
	my $j = shift;
    -f "$finishedjobinfo" or die "\n*** finishedjobinfo script '$finishedjobinfo' is not available";
	my (undef, undef, $keyvals) = split (/ /, qx($finishedjobinfo -q -M $cluster -j $j), 3);
	my %h = $keyvals =~ /([^ ]+)=([^ ]+)/g;
	return(\%h);
}

# parse list of nodes returned by finishedjobinfo
sub parseNodes($) {
	# nodes=                                # nodes=m80
	# nodes=m[26,74-75,77-78,81-84,88-89]   # nodes=m[100-101,103-104]
	# nodes=m[57,135-137]                   # nodes=m[135-136]
	my $nodes = shift;
	return ( $nodes ) if $nodes !~ /\[/;  # 0 or 1 nodes
	$nodes =~ s/^(.+)\[(.*)\]$/$2/g;  # strip off 'prefix'[ and ]
	my $node_prefix = $1;
	my @node_nums;
	foreach my $p ( split /,/, $nodes ) {
		my @r = split /-/, $p;
		push @node_nums, ($#r ? ($r[0] .. $r[1]) : $r[0]);
	}
	return map { $node_prefix . $_ } @node_nums;
}

# find jobstats files, if they exist
sub getJobstatsFiles($$@) {  # cluster jobid node-list
	my $cluster = shift; 
	my $jobid = shift; 
	my @node_list = @_;
	# print STDERR "cluster:$cluster jobid:$jobid nodelist:", join(",", @node_list), "\n";
	my @file_list;
	foreach my $node ( @node_list ) {
		my $fn = "$prefix/$cluster/uppmax_jobstats/$node/$jobid";
		-f $fn and -s $fn and push @file_list, $fn;
	}
	return @file_list;
}

# look in jobstats file for number of cores used
sub getJobstatsFileCoreCount($) {
	my $file = shift;
	open(F, "<$file") or die "*** Could not open jobstats file $file: $!";
	scalar(<F>); # header line
	my $l = <F>; # first data line
	# first 5 fields are LOCALTIME, TIME, GB_LIMIT, GB_USED, GB_SWAP_USED
	my @f = split /[ \t]+/, $l;
	return scalar(@f) - 5;
}

# reorder node list putting nodes with jobstats files first
sub reorderNodeList($$) {
    my $nl = shift; my $fl = shift;
    my @old_node_list = @{$nl};
    my @file_list = @{$fl};
    my @new_node_list;
    my %seen;
    foreach my $file ( @file_list ) {
        my @p = split("/", $file);
        push @new_node_list, $p[-2];  # node name
        ++$seen{$p[-2]};
    }
    push @new_node_list, grep { $seen{$_} ? () : $_ } @old_node_list;
    return(@new_node_list);
}

print STDOUT "jobid\tcluster\tendtime\tflag_list\tbooked\tcore_list\tnode_list\tjobstats_list\n" if ! $suppress_header;;
# print STDERR join(" -=- ", @jobs), "\n";
foreach my $jobid ( @jobs ) {
	# $cluster already declared above
	my $endtime = '.';
	my $booked = '.';
	my $total_cores = 0;
	my @flag_list;
	my @core_list;
	my @node_list;
	my @file_list,
	my @jobstats_list;

	if (@nodes) {  # -n was used, use this list
		@node_list = @nodes;
	} else {  # discover using finishedjobinfo
		my $ji = jobInfo($jobid);
		@node_list = parseNodes($ji->{nodes});
		$endtime = $ji->{end_time};
		$booked = $ji->{procs};
	}
	@file_list = getJobstatsFiles($cluster, $jobid, @node_list);
    @node_list = reorderNodeList(\@node_list, \@file_list);
    foreach ( @file_list ) {
        my $cores = getJobstatsFileCoreCount($_);
        $total_cores += $cores;
        push @core_list, $cores;
    }
    # check flags
    if (@file_list and @file_list < @node_list) {
        push @flag_list, "nodes_overbooked:" . scalar(@node_list) . ":" . scalar(@file_list);
    }
    if ($booked ne '.' and $total_cores < $booked) {
        push @flag_list, "cores_overbooked:" . $booked . ":" . $total_cores;
    }
	# jobid cluster endtime flags booked cores node[,node...] /path/to/jobstats[,/path/to/jobstats...] 
	# TODO: implement heuristic flags...
	print STDOUT "$jobid";
	print STDOUT "\t$cluster";
	print STDOUT "\t$endtime";
    print STDOUT "\t", (@flag_list ? join(",", @flag_list) : ".");
	print STDOUT "\t$booked";
	print STDOUT "\t", join(",", @core_list);
	print STDOUT "\t", join(",", @node_list);
	print STDOUT "\t", join(",", @file_list);
	print STDOUT "\n";
}

