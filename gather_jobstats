#!/usr/bin/perl

# TODO: add usage of Martin's sqlite3 db if it is available (i.e. if we are on milou-b)
# TODO: is there another, deeper, location for jobstats files we can check?

my $version = "2014-04-02";

use strict;
use warnings;
# use diagnostics;

use Getopt::Long qw(:config no_ignore_case);
use File::Basename;
use Cwd 'abs_path';

my $CWD = dirname(abs_path($0));
my $NAME = basename($0);

my $cluster = "milou";   # -M
my $do_plot = 0;         # -P
my $nodes;               # -n
my @nodes;               # after unpacking finishedjobinfo or -n
my @jobs;                # user-specified jobids
my $help;                # -h
my $stdin = 0;           # -- which indicates accepting finishedjobinfo info on stdin
my $print_header = 0;    # -d
my $quiet = 0;           # -q
my $finishedjobinfo = "/sw/uppmax/bin/finishedjobinfo"; # -f
my $plot_jobstats_R = "$CWD/plot_jobstats.R"; # -s
my $prefix = "/sw/share/slurm"; # -x
my $hard_prefix = "";    # -X
my $usage = "
$NAME  [-h] [ -p dir ] [ -f file] -M cluster [ -n node[,node...] ] [ jobid [ jobid ... ] | - ]

Discover jobstats for the specified job(s) on the specified cluster.

With the -p option, produce a plot for each jobid.  Plots contain one panel per
booked node showing CPU and memory usage, and include lines indicating the
usage flags.  Plots are saved to the current directory with the name
'cluster-jobid.png'.

Cluster is assumed '$cluster' if not specified.  There are three distinct modes
for discovery about jobs of interest.

  1. finishedjobinfo is used to discover information about jobs

         $NAME -M milou jobid1 jobid2 jobid3

  2. If the -n option is specified, then finishedjobinfo is not called and 
     jobstats files are sought for only the specified nodes

         $NAME -M milou -n m15,m16 jobid1
    
  3. Standard input is output from finishedjobinfo, which is then parsed for
     discovery.  Jobids examined are those present in the input.  This mode
     is enabled by using the - option and providing appropriate input on stdin,
     e.g.,

       finishedjobinfo my-project | grep 'jobstat=COMPLETED' | $NAME -M milou - -q -p
  
Note that not all jobs will produce jobstats files.  Also, if a job booked
nodes inefficiently by not using nodes it asked for, jobstats files will
not be available for the booked but unused nodes.

Output for each job is a tab-separated line with the following fields:

  jobid cluster endtime runtime flags booked cores node[,node...] /path/to/jobstats[,/path/to/jobstats...] 

Field contents:

  jobid    : job ID
  cluster  : cluster on which the job was run
  endtime  : end time of the job (with -n, this is '.')
  runtime  : runtime of the job (with -n, this is '.')
  flags    : flags indicating various types of resource underutilizations
  booked   : number of booked cores (with -n, this is '.')
  cores    : number of cores represented in the discovered jobstats files.
  node     : node(s) booked for the job, expanded into individual node names,
             separated by commas ','; if no nodes were found, this is '.'.  The nodes
             for which jobstats files are available are listed first.
  jobstats : jobstats files for the nodes, in the same order the nodes are listed,
             separated by commas ','; if no jobstats files were found, this is '.'

Options:

    -M cluster         Cluster on which the job was run [default is '$cluster']
    -n node[,node...]  Cluster node(s) on which the job was run.  If specified, then
                       the finishedjobinfo script is not run and discovery is
                       restricted to only the specified nodes.  Nodes can be specified
                       as a comma-separated list of complete node names, or using the
                       finishedjobinfo syntax:
                             m78,m90,m91,m92,m100  or  m[78,90-92,100]
                       Nonsensical results will occur if the syntaxes are mixed.
    - | --stdin        Accept input on stdin formatted like finishedjobinfo output.
                       The short form of this option is a single dash '-'.

    -p | --plot        Produce CPU and memory usage plot for each jobid

    -d                 Produce a header for table output
    -q                 Do not produce table output.  If -p is not specified, then the
                       script produces no output but still continues with discovery.

    -x directory       Directory prefix to use for jobstats files [default is '$prefix']
                       Directory structure is '<prefix>/<cluster>/uppmax_jobstats/<node>/<jobid>'
    -X directory       Hard directory prefix to use for jobstats files.  Jobstats files
                       are assumed available directly: '<hard-prefix>/<jobid>'
    -f file            finishedjobinfo script [default is '$finishedjobinfo']
    -s file            plot_jobstats.R script [default is '$plot_jobstats_R']
    -h                 This help information

    jobid [jobid ...]  Job number valid on the specified cluster

Location: $0
Version:  $version
";

GetOptions("M=s"   => \$cluster, 
           "n=s"   => \$nodes,
           "d"     => \$print_header,
           "q"     => \$quiet,
           "x=s"   => \$prefix,
           "X=s"   => \$hard_prefix,
           "plot"  => \$do_plot,
           "f=s"   => \$finishedjobinfo,
           "s=s"   => \$plot_jobstats_R,
           ""      => \$stdin,
           "stdin" => \$stdin,
           "help" => \$help) or die "$usage";
die "$usage" if $help;

@jobs = @ARGV;

($cluster and ($stdin or scalar(@jobs) >= 1)) or die "\n*** At least one jobid is required.\n$usage";

my $PREFIX = ( $hard_prefix ? $hard_prefix : "$prefix/$cluster/uppmax_jobstats" );

-d "$PREFIX" or die "\n*** Jobstats directory prefix '$PREFIX/' is not a directory.\n$usage";

my $username = scalar getpwuid $<;
my @user_groups = map { scalar getgrgid $_ } split ' ', $(;
my $in_staff = (scalar(grep /^staff$/, @user_groups) or ($username eq "root"));

sub parseFinishedjobinfoLine($);
sub jobInfo($);
sub parseNodes($);
sub getJobstatsFiles($$@);
sub getJobstatsFileCoreCount($);
sub reorderNodeList($$);
sub runPlotJobstats(@);

@nodes = parseNodes($nodes) if $nodes;

# parse a single finishedjobinfo-formatted line and return a hash
sub parseFinishedjobinfoLine($) {
    my $line = shift;
    chomp $line;
    my (undef, undef, $keyvals) = split (/ /, $line, 3);
    return(0) if (! defined($keyvals));
    my %h = $keyvals =~ /([^ ]+)=([^ ]+)/g;
    return(\%h);
}

# discover jobinfo for a single job using finishedjobinfo script
sub jobInfo($) {
    my $j = shift;
    -f "$finishedjobinfo" or die "\n*** finishedjobinfo script '$finishedjobinfo' not available";
    return parseFinishedjobinfoLine(qx($finishedjobinfo -q -M $cluster -j $j));
}

# parse list of nodes returned by finishedjobinfo or provided on -n
sub parseNodes($) {
    my $nodes = shift;
    # nodes=                                # nodes=m80
    # nodes=m[26,74-75,77-78,81-84,88-89]   # nodes=m[100-101,103-104]
    # nodes=m[57,135-137]                   # nodes=m[135-136]
    # nodes=m2,m3,m4,m5
    # nonsensical results if finishedjobinfo-style and comma-separated are mixed
    if ($nodes !~ /\[/) { # 0 or 1 nodes or comma-separated
        return ( $nodes =~ /,/ ? split(/,/, $nodes) : $nodes ); 
    }
    $nodes =~ s/^(.+)\[(.*)\]$/$2/g;  # strip off 'prefix'[ and ]
    my $node_prefix = $1;
    my @node_nums;
    foreach my $p ( split /,/, $nodes ) {
        my @r = split /-/, $p;
        push @node_nums, ($#r ? ($r[0] .. $r[1]) : $r[0]);
    }
    return map { $node_prefix . $_ } @node_nums;
}

# find jobstats files, if they exist
sub getJobstatsFiles($$@) {  # cluster jobid node-list
    my $cluster = shift; 
    my $jobid = shift; 
    my @node_list = @_;
    # print STDERR "cluster:$cluster jobid:$jobid nodelist:", join(",", @node_list), "\n";
    my @file_list;
    foreach my $node ( @node_list ) {
        my $fn = ( $hard_prefix ? "$PREFIX/$jobid" : "$PREFIX/$node/$jobid" );
        -f $fn and -s $fn and push @file_list, $fn;
    }
    return @file_list;
}

# look in jobstats file for number of cores used
sub getJobstatsFileCoreCount($) {
    my $file = shift;
    open(F, "<$file") or die "*** Could not open jobstats file $file: $!";
    scalar(<F>); # header line
    my $l = <F>; # first data line
    # first 5 fields are LOCALTIME, TIME, GB_LIMIT, GB_USED, GB_SWAP_USED
    my @f = split /[ \t]+/, $l;
    return scalar(@f) - 5;
}

# reorder node list putting nodes with jobstats files first
sub reorderNodeList($$) {
    my $nl = shift; my $fl = shift;
    my @old_node_list = @{$nl};
    my @file_list = @{$fl};
    my @new_node_list;
    my %seen;
    foreach my $file ( @file_list ) {
        my @p = split("/", $file);
        push @new_node_list, $p[-2];  # node name
        ++$seen{$p[-2]};
    }
    push @new_node_list, grep { $seen{$_} ? () : $_ } @old_node_list;
    return(@new_node_list);
}

sub runPlotJobstats(@) {
    my @args = @_;
    -f "$plot_jobstats_R" or die "\n*** plot_jobstats.R script '$plot_jobstats_R' not available";
    unshift @args, "--full";   # must be first, unless --no-plot
    unshift @args, "--no-plot" if ! $do_plot;  # must be first arg
    my $flags = qx($plot_jobstats_R @args);
    chomp $flags;
    return($flags);
}

my $header = "jobid\tcluster\tendtime\truntime\tflag_list\tbooked\tcore_list\tnode_list\tjobstats_list";

while ( 1 ) {

    my $jobid;
    my $input_line;

    if ($stdin) {
        $input_line = <>;
        last if ! $input_line;
    } else {
        last if ! @jobs;
        $jobid = shift @jobs;
    }

    # $cluster already declared above
    my $endtime = '.';
    my $runtime = '.';
    my $booked = '.';
    my $total_cores = 0;
    my @flag_list;
    my @core_list;
    my @node_list;
    my @file_list,
    my @jobstats_list;

    if (@nodes) {  # -n was used, use this list
        @node_list = @nodes;
    } else {  # discover using finishedjobinfo or stdin
        my $ji;
        if ($stdin) {
            $ji = parseFinishedjobinfoLine($input_line);
            die "*** Jobid cannot be found, inconsistency in stdin input" if ! $ji;
            $jobid = $ji->{jobid};
        } else {
            $ji = jobInfo($jobid);
            if (! $ji) {  # couldn't find jobinfo, give error and skip to next
                print STDERR "*** Jobid $jobid cannot be found\n";
                next;
            }
            if (! scalar(grep /^$ji->{account}$/, @user_groups) and ! $in_staff) {
                print STDERR "*** Please, do not check other projects (jobid $jobid in $ji->{account})\n";
                next;
            }
        }
        @node_list = parseNodes($ji->{nodes});
        $endtime = $ji->{end_time};
        $runtime = $ji->{runtime};
        $booked = $ji->{procs};
    }
    @file_list = getJobstatsFiles($cluster, $jobid, @node_list);
    @node_list = reorderNodeList(\@node_list, \@file_list);
    foreach ( @file_list ) {
        my $cores = getJobstatsFileCoreCount($_);
        $total_cores += $cores;
        push @core_list, $cores;
    }
    # check flags
    if (@file_list and @file_list < @node_list) {
        push @flag_list, "nodes_overbooked:" . scalar(@node_list) . ":" . scalar(@file_list);
    }
    if (@file_list and $booked ne '.' and $total_cores < $booked) {
        push @flag_list, "cores_overbooked:" . $booked . ":" . $total_cores;
    }
    # jobid cluster endtime runtime flag-list booked cores node-list jobstats-file-list
    my @fields;
    push @fields, $jobid;  # 0
    push @fields, $cluster; # 1
    push @fields, $endtime; # 2
    push @fields, $runtime; # 3
    push @fields, (@flag_list ? join(",", @flag_list) : "."); # 4
    push @fields, $booked; # 5
    push @fields, (@core_list ? join(",", @core_list) : "."); # 6
    push @fields, join(",", @node_list); # 7
    push @fields, (@file_list ? join(",", @file_list) : "."); # 8

    # if we have files to read, run plot_jobstats.R script to check more flags and produce a plot
    if (@file_list) {
        my $pjs_flags = runPlotJobstats(@fields);
        $fields[4] = $pjs_flags if $pjs_flags;
    }

    if ($print_header) {  # don't print the header until ready to create output
        print STDOUT $header, "\n" if ! $quiet;
        $print_header = 0;
    }
    print STDOUT join("\t", @fields), "\n" if ! $quiet;

}

