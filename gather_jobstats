#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use File::Basename;
use Cwd 'abs_path';

my $CWD = dirname(abs_path($0));

my $version = "2014-03-24";

my $cluster = "milou";   # -M
my $do_plot = 0;         # -P
my $nodes;               # -n
my @nodes;               # after unpacking finishedjobinfo or -n
my @jobs;                # user-specified jobids
my $help;                # -h
my $suppress_header = 0; # -d
my $finishedjobinfo = "/sw/uppmax/bin/finishedjobinfo"; # -f
my $plot_jobstats_R = "$CWD/plot_jobstats.R"; # -s
my $prefix = "/sw/share/slurm";                         # -p
my $usage = "
$0  [-h] [ -p dir ] [ -f file] -M cluster [ -n node[,node...] ] jobid [ jobid ... ]

Discover jobstats for the specified job(s) on the specified cluster.

With the -p option, produce a plot for each jobid.  Plots contain one panel per
booked node showing CPU and memory usage, and include lines indicating the
usage flags.  Plots are saved to the current directory with the name
'cluster-jobid.png'.

Cluster is assumed '$cluster' if not specified.  The finishedjobinfo script is
used to discover information about the job unless the -n option is specified.
The -n option bypasses the script and will only return jobstats files for the
specified node(s).

Note that not all jobs will produce jobstats files.  Also, if a job booked
nodes inefficiently by not using node(s) it asked for, jobstats files will
not be available for the booked but unused nodes.

Output for each job is a tab-separated line with the following fields:

  jobid cluster endtime flags booked cores node[,node...] /path/to/jobstats[,/path/to/jobstats...] 

Field contents:

  jobid    : job ID
  cluster  : cluster on which the job was run
  endtime  : end time of the job (with -n, this is '.')
  flags    : flags indicating various types of resource underutilizations
  booked   : number of booked cores (with -n, this is '.')
  cores    : number of cores represented in the discovered jobstats files.
  node     : node(s) booked for the job, expanded into individual node names,
             separated by commas ','; if no nodes were found, this is '.'.  The nodes
             for which jobstats files are available are listed first.
  jobstats : jobstats files for the nodes, in the same order the nodes are listed,
             separated by commas ','; if no jobstats files were found, this is '.'

Options:

    -M cluster         Cluster on which the job was run [default is '$cluster']
    -n node[,node...]  Cluster node(s) on which the job was run.  If specified, then
                       the finishedjobinfo script is not run and discovery is
                       restricted to only the specified nodes

    -p | --plot        Produce CPU and memory usage plot for each jobid

    -d                 Do not produce a header for the output

    -x directory       Directory prefix to use for jobstats files [default is '$prefix']
                       Directory structure is '<prefix>/<cluster>/uppmax_jobstats/<node>/i<jobid>'
    -f file            finishedjobinfo script [default is '$finishedjobinfo']
    -s file            plot_jobstats.R script [default is '$plot_jobstats_R']
    -h                 This help information

    jobid [jobid ...]  Job number valid on the specified cluster

";

GetOptions("M=s" => \$cluster, 
           "n=s" => \$nodes,
           "d"   => \$suppress_header,
           "x=s" => \$prefix,
           "plot" => \$do_plot,
           "f=s" => \$finishedjobinfo,
           "s=s" => \$plot_jobstats_R,
	   "h"   => \$help) or die "$usage";
die "$usage" if $help;

@jobs = @ARGV;

($cluster and scalar(@jobs) >= 1) or die "\n*** At least one jobid is required.\n$usage";

-d "$prefix/$cluster/uppmax_jobstats/" or die "\n*** Prefix subdirectory '$prefix/$cluster/uppmax_jobstats/' is not a directory.\n$usage";

@nodes = split /,/, $nodes if $nodes;

# discover jobinfo using finishedjobinfo script
sub jobInfo($) {
	# TODO: handle unknown jobid here, what does fji return?
	my $j = shift;
    -f "$finishedjobinfo" or die "\n*** finishedjobinfo script '$finishedjobinfo' not available";
	my (undef, undef, $keyvals) = split (/ /, qx($finishedjobinfo -q -M $cluster -j $j), 3);
	my %h = $keyvals =~ /([^ ]+)=([^ ]+)/g;
	return(\%h);
}

# parse list of nodes returned by finishedjobinfo
sub parseNodes($) {
	# nodes=                                # nodes=m80
	# nodes=m[26,74-75,77-78,81-84,88-89]   # nodes=m[100-101,103-104]
	# nodes=m[57,135-137]                   # nodes=m[135-136]
	my $nodes = shift;
	return ( $nodes ) if $nodes !~ /\[/;  # 0 or 1 nodes
	$nodes =~ s/^(.+)\[(.*)\]$/$2/g;  # strip off 'prefix'[ and ]
	my $node_prefix = $1;
	my @node_nums;
	foreach my $p ( split /,/, $nodes ) {
		my @r = split /-/, $p;
		push @node_nums, ($#r ? ($r[0] .. $r[1]) : $r[0]);
	}
	return map { $node_prefix . $_ } @node_nums;
}

# find jobstats files, if they exist
sub getJobstatsFiles($$@) {  # cluster jobid node-list
	my $cluster = shift; 
	my $jobid = shift; 
	my @node_list = @_;
	# print STDERR "cluster:$cluster jobid:$jobid nodelist:", join(",", @node_list), "\n";
	my @file_list;
	foreach my $node ( @node_list ) {
		my $fn = "$prefix/$cluster/uppmax_jobstats/$node/$jobid";
		-f $fn and -s $fn and push @file_list, $fn;
	}
	return @file_list;
}

# look in jobstats file for number of cores used
sub getJobstatsFileCoreCount($) {
	my $file = shift;
	open(F, "<$file") or die "*** Could not open jobstats file $file: $!";
	scalar(<F>); # header line
	my $l = <F>; # first data line
	# first 5 fields are LOCALTIME, TIME, GB_LIMIT, GB_USED, GB_SWAP_USED
	my @f = split /[ \t]+/, $l;
	return scalar(@f) - 5;
}

# reorder node list putting nodes with jobstats files first
sub reorderNodeList($$) {
    my $nl = shift; my $fl = shift;
    my @old_node_list = @{$nl};
    my @file_list = @{$fl};
    my @new_node_list;
    my %seen;
    foreach my $file ( @file_list ) {
        my @p = split("/", $file);
        push @new_node_list, $p[-2];  # node name
        ++$seen{$p[-2]};
    }
    push @new_node_list, grep { $seen{$_} ? () : $_ } @old_node_list;
    return(@new_node_list);
}

sub runPlotJobstats(@) {
    my @args = @_;
    -f "$plot_jobstats_R" or die "\n*** plot_jobstats.R script '$plot_jobstats_R' not available";
    unshift @args, "--full";   # must be first, unless --no-plot
    unshift @args, "--no-plot" if ! $do_plot;  # must be first arg
    my $flags = qx($plot_jobstats_R @args);
    chomp $flags;
    return($flags);
}

print STDOUT "jobid\tcluster\tendtime\tflag_list\tbooked\tcore_list\tnode_list\tjobstats_list\n" if ! $suppress_header;;
# print STDERR join(" -=- ", @jobs), "\n";
foreach my $jobid ( @jobs ) {
	# $cluster already declared above
	my $endtime = '.';
	my $booked = '.';
	my $total_cores = 0;
	my @flag_list;
	my @core_list;
	my @node_list;
	my @file_list,
	my @jobstats_list;

	if (@nodes) {  # -n was used, use this list
		@node_list = @nodes;
	} else {  # discover using finishedjobinfo
		my $ji = jobInfo($jobid);
		@node_list = parseNodes($ji->{nodes});
		$endtime = $ji->{end_time};
		$booked = $ji->{procs};
	}
	@file_list = getJobstatsFiles($cluster, $jobid, @node_list);
    @node_list = reorderNodeList(\@node_list, \@file_list);
    foreach ( @file_list ) {
        my $cores = getJobstatsFileCoreCount($_);
        $total_cores += $cores;
        push @core_list, $cores;
    }
    # check flags
    if (@file_list and @file_list < @node_list) {
        push @flag_list, "nodes_overbooked:" . scalar(@node_list) . ":" . scalar(@file_list);
    }
    if (@file_list and $booked ne '.' and $total_cores < $booked) {
        push @flag_list, "cores_overbooked:" . $booked . ":" . $total_cores;
    }
	# jobid cluster endtime flag-list booked cores node-list jobstats-file-list
    my @fields;
    push @fields, $jobid;  # 0
    push @fields, $cluster; # 1
    push @fields, $endtime; # 2
    push @fields, (@flag_list ? join(",", @flag_list) : "."); # 3
	push @fields, $booked; # 4
	push @fields, (@core_list ? join(",", @core_list) : "."); # 5
	push @fields, join(",", @node_list); # 6
	push @fields, (@file_list ? join(",", @file_list) : "."); # 7

    # if we have files to read, run plot_jobstats.R script to check more flags and produce a plot
    if (@file_list) {
        my $pjs_flags = runPlotJobstats(@fields);
        $fields[5] = $pjs_flags if $pjs_flags;
    }

    print STDOUT join("\t", @fields), "\n";

}

